\documentclass{article}
\usepackage[utf8]{inputenc}

\title{Louvain algorithm full GPU implementation}
\author{Piotr Ambroszczyk}
\date{May 2020}

\begin{document}

\maketitle

I have implemented Louvain algorithm from paper (TODO) with some modifications. In particular there are no calculations on the host side -- the whole algorithm is palatalised to GPU. The implementation uses \texttt{thrust} (TODO) library. 

\section{Modifications and Optimisations}
The biggest difference is that I decided not to implement different work distribution depending on the vertex degree. In my implementation for each graph vertex one block is responsible, and the threads in that block in parallel operate on the vertex edges.

In the paper authors used double hashing where size of each hashtable as a prime number. In my solution I have also used double hashing though the size of each hashmap was a power of $2$.


\section{Quality tests}
I have implemented small tests, the tests and outputs can be find in the (TODO) folder. The accuracy for them was calculated from the modularity formula, assuming that no edge in graph means edge with zero weight.

The program can be run with \texttt{-d} options which displays degug info but what is more important activates additional asserts checking whether constrains are preserved, e.g. checks if sum in $k$ array is the same as sum of all the weights. 

Last but not least, I have downloaded \textit{bigger} graph from SparseMatrix (add link) collecton, and checked if modularity if in the $[-1,1]$ interval and increases over time. 

\section{Experiments}
It is hard to compare results from (TODO) with presented implementation, because the authors of (TODO) use two thresholds, one for the very first modularity optimisation phase loop condition, and the second one for further iterations. The paper authors also point that the performance $~10$ times worst when single threshold is used.    




\end{document}

